(* Copyright Per Lindgren 2016, see the file "LICENSE" *)
(* for the full license governing this code.           *)

(* cimp/Parser.mly *)

%token <State__StateGen.id> ID 
%token <int> INTVAL
%token IF THEN ELSE END WHILE DO DONE FOR
%token TRUE FALSE AND NOT BEQ BLE BBE BL BB
%token SC LP RP ASSIGN PLUS MINUS MULT
%token EOF
%token <string> STRINGVAL

%left SC
%left AND
%left MINUS PLUS
%left MULT
%right NOT


%{
  open Imp__Imp 
  open Common
  open Env
  open Why3extract.Why3__BigInt
  open State__StateGen
%}

%start prog

%type <Imp__Imp.com> prog 

%%


prog:
  | com EOF                        { $1 }
  
com: 
  | com SC com                     { Cseq ($1, $3) }
  | ID ASSIGN aexpr                { Cassign ($1, $3) }
  | IF bexpr THEN com ELSE com END { Cif ($2, $4, $6) }  
  | IF bexpr THEN com END          { Cif ($2, $4, Cskip) }  
  | WHILE bexpr DO com DONE        { Cwhile ($2, $4) }
	| FOR LP ID ASSIGN aexpr SC bexpr SC ID ASSIGN aexpr RP DO com DONE { Cseq(Cassign($9, $11), Cwhile ($7, $14))}  

bexpr:
  | LP bexpr RP                    { $2 }
  | TRUE                           { Btrue }
  | FALSE                          { Bfalse }
  | bexpr AND bexpr                { Band ($1, $3) }
  | NOT bexpr                      { Bnot ($2) }
	| aexpr BL aexpr								 { Ble ($1, Asub ($3, Anum (of_int 1))) }
	| aexpr BB aexpr								 { Ble (Aadd ($3, Anum (of_int 1)), $1 ) }
  | aexpr BEQ aexpr                { Beq ($1, $3) }
  | aexpr BLE aexpr                { Ble ($1, $3) }
	| aexpr BBE aexpr								 { Ble ($3, $1) }


aexpr:
  | LP aexpr RP                    { $2 }
  | INTVAL                         { Anum (of_int $1) }
  | ID                             { Avar $1 }
  | aexpr PLUS aexpr               { Aadd ($1, $3) }
  | aexpr MINUS aexpr              { Asub ($1, $3) }
  | aexpr MULT aexpr               { Amul ($1, $3) }
	| MINUS aexpr									 	 { Asub (Anum (of_int 0), $2) }



